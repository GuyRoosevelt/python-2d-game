from typing import Optional, Callable

from pythongame.core.common import Millis, AbstractScene, SceneTransition, AbstractWorldBehavior
from pythongame.core.game_state import GameState
from pythongame.core.global_path_finder import init_global_path_finder
from pythongame.scenes.scene_factory import AbstractSceneFactory
from pythongame.scenes.scenes_game.game_engine import GameEngine
from pythongame.scenes.scenes_game.game_ui_view import GameUiView
from pythongame.world_init_util import register_game_engine_observers, register_game_state_observers


class SwitchingGameWorldScene(AbstractScene):
    def __init__(
            self,
            scene_factory: AbstractSceneFactory,
            game_engine: GameEngine,
            ui_view: GameUiView,
            character_file: str,
            total_time_played_on_character: Millis,
            create_new_game_state: Callable[[GameEngine], GameState],
            create_world_behavior: Callable[[GameState], AbstractWorldBehavior]):
        self.scene_factory = scene_factory
        self.previous_game_engine = game_engine
        self.ui_view = ui_view
        self.character_file = character_file
        self.total_time_played_on_character = total_time_played_on_character
        self.create_new_game_state = create_new_game_state
        self.create_world_behavior = create_world_behavior

    def run_one_frame(self, _time_passed: Millis) -> Optional[SceneTransition]:
        # We do this to temporarily deactivate all item effects, to later re-activate them with the new game state
        # (mainly because of how movement speed item effects modify the hero entity in the game state)
        item_inventory_slots = self.previous_game_engine.clear_item_inventory()

        # NPC's share a "global path finder" that needs to be initialized before we start creating NPCs.
        # TODO This is very messy
        path_finder = init_global_path_finder()
        new_game_state = self.create_new_game_state(self.previous_game_engine)
        path_finder.set_grid(new_game_state.pathfinder_wall_grid)

        new_world_behavior = self.create_world_behavior(new_game_state)

        # Must center camera before notifying player position as it affects which walls are shown on the minimap
        new_game_state.center_camera_on_player()
        self.ui_view.on_world_area_updated(new_game_state.entire_world_area)

        new_game_engine = GameEngine(new_game_state, self.ui_view.info_message)

        # We set up observers for gameEngine and gameState, since they are newly created in this scene. The player
        # state's observers (ui view) have already been setup in an earlier scene however.
        register_game_engine_observers(new_game_engine, self.ui_view)
        register_game_state_observers(new_game_state, self.ui_view, include_player_state=False)

        # Restore inventory that we cleared earlier
        new_game_engine.set_item_inventory(item_inventory_slots)

        # Clear any messages to give space for any messages generated by the new world behavior
        self.ui_view.info_message.clear_messages()

        # If we don't clear the minimap, there will be remains from the previous game state
        self.ui_view.minimap.clear_exploration()

        playing_scene = self.scene_factory.playing_scene(
            game_state=new_game_state,
            game_engine=new_game_engine,
            world_behavior=new_world_behavior,
            ui_view=self.ui_view,
            new_hero_was_created=False,
            character_file=self.character_file,
            total_time_played_on_character=self.total_time_played_on_character)
        return SceneTransition(playing_scene)
